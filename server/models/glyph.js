var	fs		= require('fs-extra'),
	exec	= require('child_process').exec;

var step		= require('./step');

var _			= require('underscore'),
	libxmljs	= require('libxmljs');

var config	= require('../config/config.js')();

var extract = step.fn(
		function init(err, req){
			var filename = req.query.qqfile;

			this.font = {
				dir: Date.now()
			};

			this.dir = config.dirs.static + this.font.dir + '/';
			this.file = filename.split('.').shift();

			this.fontDir = this.dir + 'font/';
			this.glyphDir = this.dir + 'glyph/';

			this.fontPath = this.fontDir + filename;

			fs.mkdirsSync(this.fontDir);
			fs.mkdirsSync(this.glyphDir);

			return req;
		},
		function start(err, req){
			var ws = fs.createWriteStream(this.fontPath);

			req.on('data', function(data){
				ws.write(data);
			});
			req.on('end', this);
		},
		function fontinfo(err) {
			var self = this,
				command = ['cd', config.dirs.script, '&& ./fontname.py ', this.fontPath].join(' ');

			exec(command, function(err, data){
				self.font.name = data;
				self();
			});
		},
		function extract(err){
			var command = ['cd', config.dirs.script, '&& ./exportglyphs.py -p', this.glyphDir, this.fontPath].join(' ');

			exec(command, this);
		},
		function parse(err, out){
			var dir = this.font.dir,
				attrs = ['file', 'name', 'code'];
			this.font.glyphs = _.chain(out.split('\n'))
				.compact()
				.map(function(line){
					var glyph =  _.object(attrs, line.split('|'));
					return _.extend(glyph, { dir: dir });
				})
				.value();
			return this.font;
		}
	),
	download = step.fn(
		function start(err, req){
			this.tmp = Date.now();
			this.zip = config.dirs.static + this.tmp + '.zip';
			this.path = config.dirs.static + this.tmp + '/';

			this.fonts = req.body.fonts;
			this.options = req.body.options;

			var fonttype = this.options.fonttype;
			if (_.isString(fonttype)){
				this.options.fonttype = [fonttype];				
			}

			return this.path;
		},
		function mkdir(err, dir){
			fs.mkdir(dir, this);
		},
		function stylesheet(err){
			var need = this.options.fonttype,
				base64 = this.options.base64,
				stylesheet = _.map(this.fonts, function(font){
					var filename = config.dirs.static + font.dirname + '/' + font.filename,
						woff = !base64 ? '"' + filename + '.woff"' : 'data:font/woff;charset=utf-8;base64,' + b64(filename + '.woff'),
						ttf = !base64 ? '"' + filename + '.ttf"' : 'data:font/truetype;charset=utf-8;base64,' + b64(filename + '.ttf');

					var	all = {
							woff: '		url(' + woff + ') format("woff")',
							 ttf: '		url(' + ttf + ') format("truetype")',
							 svg: '		url("' + font.filename + '.svg#' + font.fontid + '") format("svg")',
							 eot: '		url("' + font.filename + '.eot?#iefix") format("embedded-opentype")'
						},
						pick = _.values(_.pick(all, need)).join(',\n') + ';';
					var css = ['@font-face {',
							'	font-family: "' + font.family + '";',
							'	font-style: ' + font.style + ';',
							'	font-weight: ' + font.weight + ';'
						];
					if (_.indexOf(need, 'eot') !== -1) {
						css.push('	src: url("' + font.filename + '.eot");');
					}
					css.push('	src: local("' + font.family + '"),');
					css.push(pick);
					css.push('}');
					return css.join('\n');
				}).join('\n');

			stylesheet = '\/* Generated by Designmodo (http://designmodo.com/fontface/) *\/ \n\n' + stylesheet;

			var stylefile = this.path + (this.options.stylename || 'stylesheet') + '.css';

			fs.writeFile(stylefile, stylesheet, this);
		},
		function prepare(err){
			var fonttype = this.options.fonttype,
				base64 = this.options.base64,
				dirdest = this.path,
				list;
			list = _.map(this.fonts, function(font){
				var dirsource = config.dirs.static + font.dirname + '/',
					filename = font.filename;
				return _.map(fonttype, function(type){
					if ((/(woff|ttf)/).test(type) && base64) {
						return undefined;
					}
					var file = filename + '.' + type;
					return { source: dirsource + file, dest: dirdest + file };
				});
			});

			list = _.compact(_.flatten(list));

			copy(list, this);
		},
		function compress(err){
			var source = this.path,
				dest = this.zip;
			exec('cd ' + this.path + '../ && zip -r -9 ' + this.tmp + '.zip ' + this.tmp, this);
		},
		function end(err){
			return { 
				href: config.host.static + this.tmp + '.zip'
			}
		}
	);

exports.upload = function(req, done){
	var done = typeof done === 'function' ? 
			done : function(){ };
	upload(null, req, done);
};

exports.download = function(req, done){
	var done = typeof done === 'function' ? 
			done : function(){ };
	download(null, req, done);
};